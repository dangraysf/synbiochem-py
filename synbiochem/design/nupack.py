'''
PartsGenie (c) University of Manchester 2015

PartsGenie is licensed under the MIT License.

To view a copy of this license, visit <http://opensource.org/licenses/MIT/>.

@author:  neilswainston
'''
# pylint: disable=too-many-arguments
import popen2
import tempfile
import time


class NuPackRunner(object):
    '''Wrapper class for running NuPACK jobs.'''

    def __init__(self, temp=37.0):
        self.__temp = temp
        self.__cache = {}

    def mfe(self, sequences, dangles='some'):
        '''Runs mfe.'''
        return self.__get('mfe', sequences, dangles)

    def subopt(self, sequences, energy_gap, dangles='some'):
        '''Runs subopt.'''
        return self.__get(
            'subopt', sequences, dangles, energy_gap=energy_gap)

    def energy(self, sequences, bp_x, bp_y, dangles='some'):
        '''Runs energy.'''
        return self.__get('energy', sequences, dangles, bp_x=bp_x,
                          bp_y=bp_y)

    def __get(self, cmd, sequences, dangles, energy_gap=None, bp_x=None,
              bp_y=None):
        '''Gets the NuPACK result (which may be cached).'''
        key = ';'.join([cmd, str(sequences), dangles, str(energy_gap),
                        str(bp_x), str(bp_y)])

        if key not in self.__cache:
            self.__cache[key] = self.__run(cmd, sequences, dangles, energy_gap,
                                           bp_x, bp_y)

        return self.__cache[key]

    def __run(self, cmd, sequences, dangles, energy_gap=None, bp_x=None,
              bp_y=None):
        '''Runs NuPACK.'''
        filename = _write_input(sequences, energy_gap=energy_gap, bp_x=bp_x,
                                bp_y=bp_y)

        args = ' -T ' + str(self.__temp) + \
            ' -multi -material rna1999 -dangles ' + dangles + ' '

        output = popen2.Popen3(cmd + args + filename)

        while output.poll() < 0:
            output.wait()
            time.sleep(0.001)

        try:
            with open(filename + '.' + cmd) as out_file:
                return _read_output(out_file)
        except IOError:
            # Skip the comments of the text file
            line = output.fromchild.readline()
            while line[0] == '%':
                line = output.fromchild.readline()

            return float(line)


def _write_input(sequences, energy_gap=None, bp_x=None, bp_y=None):
    '''Creates the input file functions.'''
    tmpfile = tempfile.NamedTemporaryFile(delete=False, suffix='.in')

    with open(tmpfile.name, 'w') as fle:
        fle.write(str(len(sequences)) + '\n')
        fle.write('\n'.join(sequences) + '\n')
        fle.write(' '.join([str(x + 1)
                            for x in range(len(sequences))]) + '\n')

        if energy_gap is not None:
            fle.write(str(energy_gap) + '\n')

        if bp_x is not None and bp_y is not None:
            for pos in range(len(bp_x)):
                fle.write(str(bp_x[pos]) + '\t' + str(bp_y[pos]) + '\n')

    return tmpfile.name[:-3]


def _read_output(out_file):
    '''Read the output text file generated by NuPACK.'''

    # Skip the comments of the text file
    line = out_file.readline()
    while line[0] == '%':
        line = out_file.readline()

    energies = []
    bp_xs = []
    bp_ys = []

    while line:
        words = line.split()

        if not line == '\n' and not words[0] == '%' and not words[0] == '':

            # Read the line containing the number of total nucleotides in
            # the complex

            # Read the line containing the mfe
            words = out_file.readline().split()
            energies.append(float(words[0]))

            # Skip the line containing the dot/parens description of the
            # secondary structure
            line = out_file.readline()

            # Read in the lines containing the base pairing description of
            # the secondary structure
            # Continue reading until a % comment
            bp_x = []
            bp_y = []

            line = out_file.readline()
            words = line.split()
            while not line == '\n' and not words[0] == '%':
                bp_x.append(int(words[0]))
                bp_y.append(int(words[1]))
                words = out_file.readline().split()

            bp_xs.append(bp_x)
            bp_ys.append(bp_y)

        line = out_file.readline()

    return energies, bp_xs, bp_ys
