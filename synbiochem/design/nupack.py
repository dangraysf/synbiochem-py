'''
PartsGenie (c) University of Manchester 2015

PartsGenie is licensed under the MIT License.

To view a copy of this license, visit <http://opensource.org/licenses/MIT/>.

@author:  neilswainston
'''
import popen2
import tempfile
import time


class NuPackRunner(object):
    '''Wrapper class for running NuPACK jobs.'''

    def __init__(self, temp=37.0):
        self.__temp = temp

    def mfe(self, sequences, dangles='some'):
        '''Runs mfe.'''
        cmd = 'mfe'
        _, filename = self.__run(cmd, _write_input(sequences), dangles)
        return _read_output(filename + '.' + cmd)

    def subopt(self, sequences, energy_gap, dangles='some'):
        '''Runs subopt.'''
        cmd = 'subopt'
        _, filename = self.__run(cmd,
                                 _write_input(sequences,
                                              energy_gap=energy_gap),
                                 dangles)
        return _read_output(filename + '.' + cmd)

    def energy(self, sequences, bp_x, bp_y, dangles='some'):
        '''Runs energy.'''
        cmd = 'energy'
        output, _ = self.__run(cmd, _write_input(sequences, bp_x=bp_x,
                                                 bp_y=bp_y), dangles)

        # Skip the comments of the text file
        line = output.fromchild.readline()
        while line[0] == '%':
            line = output.fromchild.readline()

        return float(line)

    def __run(self, cmd, filename, dangles):
        '''Runs NuPACK.'''
        args = ' -T ' + str(self.__temp) + \
            ' -multi -material rna1999 -dangles ' + dangles + ' '

        output = popen2.Popen3(cmd + args + filename)

        while output.poll() < 0:
            output.wait()
            time.sleep(0.001)

        return output, filename


def _write_input(sequences, energy_gap=None, bp_x=None, bp_y=None):
    '''Creates the input file functions.'''
    tmpfile = tempfile.NamedTemporaryFile(delete=False, suffix='.in')

    with open(tmpfile.name, 'w') as fle:
        fle.write(str(len(sequences)) + '\n')
        fle.write('\n'.join(sequences) + '\n')
        fle.write(' '.join([str(x + 1)
                            for x in range(len(sequences))]) + '\n')

        if energy_gap is not None:
            fle.write(str(energy_gap) + '\n')

        if bp_x is not None and bp_y is not None:
            for pos in range(len(bp_x)):
                fle.write(str(bp_x[pos]) + '\t' + str(bp_y[pos]) + '\n')

    return tmpfile.name[:-3]


def _read_output(filename):
    '''Read the output text file generated by NuPACK.'''
    handle = open(filename, 'rU')

    # Skip the comments of the text file
    line = handle.readline()
    while line[0] == '%':
        line = handle.readline()

    energies = []
    bp_xs = []
    bp_ys = []

    while line:
        words = line.split()

        if not line == '\n' and not words[0] == '%' and not words[0] == '':

            # Read the line containing the number of total nucleotides in
            # the complex

            # Read the line containing the mfe
            words = handle.readline().split()
            energies.append(float(words[0]))

            # Skip the line containing the dot/parens description of the
            # secondary structure
            line = handle.readline()

            # Read in the lines containing the base pairing description of
            # the secondary structure
            # Continue reading until a % comment
            bp_x = []
            bp_y = []

            line = handle.readline()
            words = line.split()
            while not line == '\n' and not words[0] == '%':
                bp_x.append(int(words[0]))
                bp_y.append(int(words[1]))
                words = handle.readline().split()

            bp_xs.append(bp_x)
            bp_ys.append(bp_y)

        line = handle.readline()
    handle.close()

    return energies, bp_xs, bp_ys
